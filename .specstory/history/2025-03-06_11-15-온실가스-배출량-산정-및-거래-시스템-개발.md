<!-- Generated by SpecStory -->

# 온실가스 배출량 산정 및 거래 시스템 개발 (2025-03-06 20:15:59)

_**User**_

나는 자동화된 온실가스 배출량 산정하고 이를 배출권 거래제와 연결지을려고해. 코딩은 파이썬 위주로 진행할 예정이고 vs code에서 작성할거야. 개발 방향은 Flask와 FastAPI로 백엔드를 구축할 거야. 모델은 Pandas를 기반으로 데이터를 처리할 거고 엑셀 데이터를 업로드하면 분석 기능을 중심으로 2024년 예상 배출량을 계산하고 현재 배출권 보유량을 보고 구매 필요량 또는 판매를 추천해주는 프로그램을 만들어 보려고해.


---

_**Assistant**_

<think>사용자는 자동화된 온실가스 배출량 산정 및 배출권 거래제 연결 프로그램을 개발하려고 합니다. 주요 요구사항을 정리해보겠습니다:

1. 개발 언어: 파이썬
2. IDE: VS Code
3. 백엔드: Flask 및 FastAPI 
4. 데이터 처리: Pandas
5. 기능:
   - 엑셀 데이터 업로드
   - 2024년 예상 배출량 계산
   - 현재 배출권 보유량 확인
   - 구매 필요량 또는 판매 추천

이 프로젝트의 개발 계획과 아키텍처를 설계하고, 초기 코드를 제안하겠습니다. 한국어로 응답해야 합니다.</think># 온실가스 배출량 산정 및 배출권 거래 자동화 시스템 개발 계획

## 개발 계획

### 1. 시스템 구조
```
프로젝트/
├── backend/
│   ├── app.py             # FastAPI 메인 애플리케이션
│   ├── models/            # 데이터 모델
│   │   ├── emission.py    # 배출량 계산 모델
│   │   └── trading.py     # 배출권 거래 모델
│   ├── routers/           # API 라우터
│   │   ├── upload.py      # 파일 업로드 라우터
│   │   ├── calculation.py # 계산 라우터
│   │   └── trading.py     # 거래 추천 라우터
│   └── utils/             # 유틸리티 함수
│       └── excel.py       # 엑셀 처리 유틸리티
├── frontend/              # 프론트엔드 코드 (필요시)
└── requirements.txt       # 필요 패키지
```

### 2. 주요 기능 구현 계획
1. 엑셀 파일 업로드 및 파싱
2. 과거 데이터 기반 2024년 배출량 예측 모델
3. 현재 배출권 보유량 입력 및 관리
4. 예측 배출량과 보유량 비교를 통한 거래 추천
5. 결과 시각화 및 리포트 생성

## 코드 구현

### 1. `requirements.txt` 파일
```text:requirements.txt
fastapi==0.103.1
uvicorn==0.23.2
pandas==2.1.0
numpy==1.25.2
openpyxl==3.1.2
python-multipart==0.0.6
scikit-learn==1.3.0
matplotlib==3.7.2
```

### 2. `app.py` - FastAPI 메인 애플리케이션
```python:backend/app.py
from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import pandas as pd
import numpy as np
from typing import Optional
import io
import uvicorn

from models.emission import EmissionCalculator
from models.trading import TradingAdvisor

app = FastAPI(title="온실가스 배출량 산정 및 배출권 거래 추천 시스템")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    return {"message": "온실가스 배출량 산정 및 배출권 거래 추천 시스템에 오신 것을 환영합니다."}

@app.post("/upload-emission-data/")
async def upload_emission_data(file: UploadFile = File(...)):
    if not file.filename.endswith(('.xlsx', '.xls')):
        raise HTTPException(status_code=400, detail="Excel 파일만 업로드 가능합니다.")
    
    try:
        contents = await file.read()
        df = pd.read_excel(io.BytesIO(contents))
        
        # 데이터 유효성 검사
        required_columns = ["연도", "월", "배출량"]
        if not all(col in df.columns for col in required_columns):
            raise HTTPException(status_code=400, detail=f"필수 열이 누락되었습니다: {required_columns}")
        
        # 임시 세션 저장소에 데이터 저장 (실제 구현에서는 DB 사용 권장)
        # 이 예제에서는 DataFrame을 JSON으로 변환하여 반환
        
        calculator = EmissionCalculator(df)
        prediction_2024 = calculator.predict_emissions_for_2024()
        
        return {
            "message": "파일이 성공적으로 업로드되었습니다.",
            "data_preview": df.head().to_dict(),
            "predicted_emission_2024": prediction_2024
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"처리 중 오류가 발생했습니다: {str(e)}")

@app.post("/trading-recommendation/")
async def get_trading_recommendation(
    predicted_emission: float = Form(...),
    current_allowance: float = Form(...),
    current_price: Optional[float] = Form(None)
):
    advisor = TradingAdvisor(predicted_emission, current_allowance, current_price)
    recommendation = advisor.get_recommendation()
    
    return recommendation

if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)
```

### 3. `emission.py` - 배출량 계산 모델
```python:backend/models/emission.py
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from typing import Dict, List, Union

class EmissionCalculator:
    def __init__(self, emission_data: pd.DataFrame):
        self.data = emission_data
        self.prepare_data()
    
    def prepare_data(self):
        """데이터 전처리 및 준비"""
        # 연도와 월을 시간 순서로 정렬
        self.data['날짜'] = pd.to_datetime(self.data['연도'].astype(str) + '-' + self.data['월'].astype(str))
        self.data = self.data.sort_values('날짜')
        
        # 필요한 경우 결측치 처리
        self.data['배출량'] = self.data['배출량'].fillna(method='ffill')
    
    def predict_emissions_for_2024(self) -> Dict[str, Union[float, List[float]]]:
        """2024년 예상 배출량 계산"""
        # 연도별 배출량 추세 계산
        yearly_emissions = self.data.groupby('연도')['배출량'].sum().reset_index()
        X = yearly_emissions['연도'].values.reshape(-1, 1)
        y = yearly_emissions['배출량'].values
        
        # 선형 회귀 모델로 2024년 예측
        model = LinearRegression()
        model.fit(X, y)
        predicted_2024 = float(model.predict([[2024]])[0])
        
        # 월별 분포 계산 (최근 3년 평균 비율 사용)
        recent_years = self.data['연도'].unique()[-3:] if len(self.data['연도'].unique()) >= 3 else self.data['연도'].unique()
        recent_data = self.data[self.data['연도'].isin(recent_years)]
        
        monthly_ratio = []
        for year in recent_years:
            year_data = recent_data[recent_data['연도'] == year]
            year_total = year_data['배출량'].sum()
            for month in range(1, 13):
                month_data = year_data[year_data['월'] == month]
                if not month_data.empty:
                    ratio = month_data['배출량'].sum() / year_total
                    monthly_ratio.append((month, ratio))
        
        # 월별 평균 비율 계산
        monthly_avg_ratio = {}
        for month in range(1, 13):
            month_ratios = [r for m, r in monthly_ratio if m == month]
            monthly_avg_ratio[month] = sum(month_ratios) / len(month_ratios) if month_ratios else 1/12
            
        # 2024년 월별 예측 배출량
        monthly_predictions = {month: predicted_2024 * ratio for month, ratio in monthly_avg_ratio.items()}
        
        return {
            "yearly_total": predicted_2024,
            "monthly_breakdown": monthly_predictions
        }
    
    def analyze_emission_trends(self):
        """배출량 추세 분석"""
        # 연도별 증감율 계산
        yearly_emissions = self.data.groupby('연도')['배출량'].sum().reset_index()
        yearly_emissions['증감율'] = yearly_emissions['배출량'].pct_change() * 100
        
        # 계절별 패턴 분석
        self.data['계절'] = (self.data['월'] % 12 + 3) // 3
        seasonal_emissions = self.data.groupby(['연도', '계절'])['배출량'].sum().reset_index()
        
        return {
            "yearly_trend": yearly_emissions.to_dict('records'),
            "seasonal_pattern": seasonal_emissions.to_dict('records')
        }
```

### 4. `trading.py` - 배출권 거래 추천 모델
```python:backend/models/trading.py
class TradingAdvisor:
    def __init__(self, predicted_emission: float, current_allowance: float, current_price: float = None):
        self.predicted_emission = predicted_emission
        self.current_allowance = current_allowance
        self.current_price = current_price or 30000  # 기본 배출권 가격(원) 설정
    
    def get_recommendation(self):
        """배출권 거래 추천"""
        difference = self.current_allowance - self.predicted_emission
        
        if difference > 0:
            # 잉여 배출권이 있는 경우
            recommendation_type = "판매"
            amount = difference
            estimated_value = amount * self.current_price
            
            # 판매 전략 결정
            if difference < 0.05 * self.current_allowance:  # 잉여량이 5% 미만일 경우
                strategy = "일부 보유 권장: 소량만 판매하고 나머지는 다음 연도를 위해 보유하세요."
            else:
                strategy = "적극 판매 권장: 잉여 배출권을 현재 시세에 판매하는 것이 유리합니다."
                
        elif difference < 0:
            # 배출권이 부족한 경우
            recommendation_type = "구매"
            amount = abs(difference)
            estimated_value = amount * self.current_price
            
            # 구매 전략 결정
            deficit_percentage = abs(difference) / self.predicted_emission * 100
            if deficit_percentage < 10:  # 부족량이 10% 미만일 경우
                strategy = "점진적 구매: 시장 가격 변동을 모니터링하며 점진적으로 구매하세요."
            else:
                strategy = "즉시 구매 권장: 필요 배출권을 빠른 시일 내에 확보하세요."
        else:
            # 배출권이 정확히 맞는 경우
            recommendation_type = "유지"
            amount = 0
            estimated_value = 0
            strategy = "현재 배출권이 예상 배출량과 정확히 일치합니다. 추가 조치가 필요 없습니다."
        
        return {
            "recommendation_type": recommendation_type,
            "amount": amount,
            "estimated_value": estimated_value,
            "strategy": strategy,
            "details": {
                "predicted_emission": self.predicted_emission,
                "current_allowance": self.current_allowance,
                "difference": difference,
                "current_price": self.current_price
            }
        }
        
    def simulate_scenarios(self, price_variations=None):
        """다양한 가격 시나리오에서 거래 시뮬레이션"""
        if price_variations is None:
            price_variations = [0.8, 0.9, 1.0, 1.1, 1.2]  # 기본 가격의 80%, 90%, 100%, 110%, 120%
            
        scenarios = []
        base_price = self.current_price
        
        for variation in price_variations:
            self.current_price = base_price * variation
            recommendation = self.get_recommendation()
            scenarios.append({
                "price_factor": variation,
                "price": self.current_price,
                "recommendation": recommendation
            })
            
        self.current_price = base_price  # 원래 가격으로 복원
        return scenarios
```

### 5. `excel.py` - 엑셀 처리 유틸리티
```python:backend/utils/excel.py
import pandas as pd
import io
from typing import Dict, Any, List

def validate_emission_data(df: pd.DataFrame) -> Dict[str, Any]:
    """업로드된 배출량 데이터의 유효성 검사"""
    validation_results = {
        "is_valid": True,
        "errors": [],
        "warnings": []
    }
    
    # 필수 열 확인
    required_columns = ["연도", "월", "배출량"]
    missing_columns = [col for col in required_columns if col not in df.columns]
    
    if missing_columns:
        validation_results["is_valid"] = False
        validation_results["errors"].append(f"필수 열이 누락되었습니다: {missing_columns}")
        
    # 데이터 타입 확인
    if "연도" in df.columns and not pd.api.types.is_numeric_dtype(df["연도"]):
        validation_results["warnings"].append("'연도' 열이 숫자 형식이 아닙니다.")
        
    if "월" in df.columns and not pd.api.types.is_numeric_dtype(df["월"]):
        validation_results["warnings"].append("'월' 열이 숫자 형식이 아닙니다.")
        
    if "배출량" in df.columns and not pd.api.types.is_numeric_dtype(df["배출량"]):
        validation_results["is_valid"] = False
        validation_results["errors"].append("'배출량' 열이 숫자 형식이 아닙니다.")
    
    # 데이터 범위 확인
    if "월" in df.columns and pd.api.types.is_numeric_dtype(df["월"]):
        invalid_months = df[~df["월"].between(1, 12)]["월"].unique()
        if len(invalid_months) > 0:
            validation_results["warnings"].append(f"유효하지 않은 월 값이 있습니다: {invalid_months}")
    
    # 결측치 확인
    missing_values = df[required_columns].isnull().sum()
    if missing_values.sum() > 0:
        validation_results["warnings"].append(f"결측치가 있습니다: {missing_values.to_dict()}")
    
    return validation_results

def generate_report(predictions: Dict[str, Any], recommendation: Dict[str, Any]) -> pd.DataFrame:
    """예측 결과와 추천 사항을 포함한 보고서 생성"""
    # 월별 예측 데이터 DataFrame으로 변환
    monthly_data = []
    for month, amount in predictions["monthly_breakdown"].items():
        monthly_data.append({
            "월": month,
            "예상 배출량": amount
        })
    
    monthly_df = pd.DataFrame(monthly_data)
    
    # 거래 추천 정보
    recommendation_data = {
        "총 예상 배출량": predictions["yearly_total"],
        "현재 보유 배출권": recommendation["details"]["current_allowance"],
        "차이": recommendation["details"]["difference"],
        "추천 거래 유형": recommendation["recommendation_type"],
        "거래 필요 수량": recommendation["amount"],
        "예상 거래 금액": recommendation["estimated_value"],
        "추천 전략": recommendation["strategy"]
    }
    
    recommendation_df = pd.DataFrame([recommendation_data])
    
    return {
        "monthly_prediction": monthly_df,
        "recommendation": recommendation_df
    }
```

## 시스템 사용 방법

1. 시스템 구동하기:
   ```
   uvicorn backend.app:app --reload
   ```

2. API 엔드포인트 사용:
   - `/upload-emission-data/`: 과거 온실가스 배출량 데이터 업로드 (엑셀 파일)
   - `/trading-recommendation/`: 배출권 거래 추천 받기

3. 필요한 데이터 형식:
   - 배출량 데이터: "연도", "월", "배출량" 열이 포함된 엑셀 파일
   - 거래 추천을 위한 입력: 예측 배출량, 현재 보유 배출권, 현재 배출권 시장 가격

## 향후 개선 방향

1. 데이터베이스 연동으로 히스토리 관리
2. 머신러닝 모델을 통한 더 정확한 배출량 예측
3. 배출권 시장 가격 API 연동
4. 웹 인터페이스 구현
5. 데이터 시각화 대시보드 추가

이 코드는 기본적인 구현을 제공하며, 실제 사용을 위해서는 데이터 형식과 비즈니스 요구사항에 맞게 커스터마이징이 필요합니다.

---



---

